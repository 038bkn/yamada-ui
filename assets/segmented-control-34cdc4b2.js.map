{"version":3,"file":"segmented-control-34cdc4b2.js","sources":["../../packages/components/segmented-control/src/segmented-control.tsx"],"sourcesContent":["import {\n  ui,\n  forwardRef,\n  useMultiComponentStyle,\n  omitThemeProps,\n  CSSUIObject,\n  HTMLUIProps,\n  ThemeProps,\n} from \"@yamada-ui/core\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { createDescendant } from \"@yamada-ui/use-descendant\"\nimport { trackFocusVisible } from \"@yamada-ui/use-focus-visible\"\nimport { useResizeObserver } from \"@yamada-ui/use-resize-observer\"\nimport {\n  ariaAttr,\n  createContext,\n  cx,\n  dataAttr,\n  getValidChildren,\n  handlerAll,\n  mergeRefs,\n  omitObject,\n  PropGetter,\n  RequiredPropGetter,\n  useCallbackRef,\n  useIsMounted,\n} from \"@yamada-ui/utils\"\nimport {\n  ChangeEvent,\n  ChangeEventHandler,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useId,\n  useRef,\n  useState,\n} from \"react\"\n\nexport type SegmentedControlItem = SegmentedControlButtonProps & {\n  label?: string\n}\n\nconst { DescendantsContextProvider, useDescendants, useDescendant } =\n  createDescendant<HTMLButtonElement>()\n\ntype SegmentedControlContext = {\n  getInputProps: RequiredPropGetter<{ index: number }>\n  getLabelProps: RequiredPropGetter<{ index: number }>\n  styles: Record<string, CSSUIObject>\n}\n\nconst [SegmentedControlProvider, useSegmentedControl] =\n  createContext<SegmentedControlContext>({\n    strict: false,\n    name: \"SegmentedControlContext\",\n  })\n\ntype SegmentedControlOptions = {\n  /**\n   * The HTML `name` attribute used for forms.\n   */\n  name?: string\n  /**\n   * The value of the segmented control.\n   */\n  value?: string\n  /**\n   * The initial value of the segmented control.\n   */\n  defaultValue?: string\n  /**\n   * The callback fired when any children radio is checked or unchecked.\n   */\n  onChange?: (value: string) => void\n  /**\n   * If `true`, the segmented control will be readonly.\n   *\n   * @default false\n   */\n  isReadOnly?: boolean\n  /**\n   * If `true`, the segmented control will be disabled.\n   *\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If provided, generate segmented control buttons but based on items.\n   *\n   * @default '[]'\n   */\n  items?: SegmentedControlItem[]\n}\n\nexport type SegmentedControlProps = Omit<HTMLUIProps<\"div\">, \"onChange\"> &\n  ThemeProps<\"SegmentedControl\"> &\n  SegmentedControlOptions\n\nexport const SegmentedControl = forwardRef<SegmentedControlProps, \"div\">(\n  (props, ref) => {\n    const [styles, mergedProps] = useMultiComponentStyle(\n      \"SegmentedControl\",\n      props,\n    )\n    let {\n      className,\n      id,\n      name,\n      isReadOnly,\n      isDisabled,\n      children,\n      items = [],\n      ...rest\n    } = omitThemeProps(mergedProps)\n    const isMoutedRef = useIsMounted()\n\n    id = id ?? useId()\n    name = name ?? `segmented-control-${useId()}`\n\n    rest.onChange = useCallbackRef(rest.onChange)\n\n    const descendants = useDescendants()\n\n    const [focusedIndex, setFocusedIndex] = useState<number>(-1)\n    const [isFocusVisible, setIsFocusVisible] = useState<boolean>(false)\n    const [observerRef, containerRect] = useResizeObserver()\n    const containerRef = useRef<HTMLDivElement>(null)\n    const labelRefs = useRef<Map<string | number, HTMLLabelElement>>(new Map())\n\n    const [value, setValue] = useControllableState({\n      value: rest.value,\n      defaultValue: rest.defaultValue,\n      onChange: rest.onChange,\n    })\n\n    const getActivePosition = useCallback(() => {\n      const rect = { width: 0, height: 0, x: 0, y: 0 }\n\n      const el = labelRefs.current.get(value)\n\n      if (!el || !containerRef.current || !observerRef.current) return rect\n\n      const { paddingLeft, paddingTop } = getComputedStyle(containerRef.current)\n\n      const gutterX = parseFloat(paddingLeft) || 0\n      const gutterY = parseFloat(paddingTop) || 0\n\n      let { width, height } = el.getBoundingClientRect()\n      rect.x = el.offsetLeft - gutterX\n      rect.y = el.offsetTop - gutterY\n\n      rect.width = width * (el.offsetWidth / width) || 0\n      rect.height = height * (el.offsetWidth / width) || 0\n\n      return rect\n    }, [observerRef, value])\n\n    const [activePosition, setActivePosition] = useState(getActivePosition)\n\n    const onChange = useCallback(\n      (ev: ChangeEvent<HTMLInputElement>) => {\n        if (isDisabled || isReadOnly) {\n          ev.preventDefault()\n\n          return\n        }\n\n        setValue(ev.target.value)\n      },\n      [isDisabled, isReadOnly, setValue],\n    )\n\n    const onFocus = useCallback(\n      (index: number, skip: boolean) => {\n        if (isDisabled) return\n\n        if (skip) {\n          const next = descendants.enabledNextValue(index)\n\n          if (next) setFocusedIndex(next.index)\n        } else {\n          setFocusedIndex(index)\n        }\n      },\n      [descendants, isDisabled],\n    )\n\n    const onBlur = useCallback(() => setFocusedIndex(-1), [])\n\n    const getContainerProps: PropGetter = useCallback(\n      (props = {}, ref = null) => ({\n        ...omitObject(rest, [\"value\", \"defaultValue\", \"onChange\"]),\n        ...props,\n        ref: mergeRefs(containerRef, observerRef, ref),\n        id,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"aria-readonly\": ariaAttr(isReadOnly),\n        onBlur: handlerAll(props.onBlur, onBlur),\n      }),\n      [id, isDisabled, isReadOnly, observerRef, onBlur, rest],\n    )\n\n    const getActiveProps: PropGetter = useCallback(\n      (props = {}, ref = null) => {\n        const { width, height, x, y } = activePosition\n\n        return {\n          ...props,\n          ref,\n          style: {\n            position: \"absolute\",\n            zIndex: 1,\n            width,\n            height,\n            transform: `translate(${x}px, ${y}px)`,\n          },\n        }\n      },\n      [activePosition],\n    )\n\n    const getInputProps: RequiredPropGetter<{ index: number }> = useCallback(\n      ({ index, ...props } = {}, ref = null) => {\n        const disabled = props.disabled ?? props.isDisabled ?? isDisabled\n        const readOnly = props.readOnly ?? props.isReadOnly ?? isReadOnly\n        const checked = props.value === value\n\n        return {\n          ...omitObject(props, [\"isDisabled\", \"isReadOnly\"]),\n          ref,\n          id: `${id}-${index}`,\n          type: \"radio\",\n          name,\n          disabled: disabled || readOnly,\n          readOnly,\n          checked,\n          \"aria-disabled\": ariaAttr(disabled),\n          \"aria-readonly\": ariaAttr(readOnly),\n          \"data-checked\": dataAttr(checked),\n          \"data-focus\": dataAttr(index === focusedIndex),\n          style: {\n            border: \"0px\",\n            clip: \"rect(0px, 0px, 0px, 0px)\",\n            height: \"1px\",\n            width: \"1px\",\n            margin: \"-1px\",\n            padding: \"0px\",\n            overflow: \"hidden\",\n            whiteSpace: \"nowrap\",\n            position: \"absolute\",\n          },\n          onChange: handlerAll(props.onChange, (ev) =>\n            !disabled && !readOnly\n              ? onChange(ev as ChangeEvent<HTMLInputElement>)\n              : {},\n          ),\n        }\n      },\n      [isDisabled, isReadOnly, value, id, name, focusedIndex, onChange],\n    )\n\n    const getLabelProps: RequiredPropGetter<{ index: number }> = useCallback(\n      ({ index, ...props } = {}, ref = null) => {\n        const disabled = props.disabled ?? props.isDisabled ?? isDisabled\n        const readOnly = props.readOnly ?? props.isReadOnly ?? isReadOnly\n        const checked = props.value === value\n        const focused = index === focusedIndex\n\n        return {\n          props,\n          ref: mergeRefs(\n            (node) => labelRefs.current.set(props.value, node),\n            ref,\n          ),\n          \"aria-disabled\": ariaAttr(disabled),\n          \"aria-readonly\": ariaAttr(readOnly),\n          \"data-checked\": dataAttr(checked),\n          \"data-focus\": dataAttr(focused),\n          \"data-focus-visible\": dataAttr(focused && isFocusVisible),\n          onFocus: handlerAll(props.onFocus, () =>\n            onFocus(index, disabled || readOnly),\n          ),\n          ...(disabled || readOnly\n            ? {\n                _hover: {},\n                _active: {},\n                _focus: {},\n                _invalid: {},\n                _focusVisible: {},\n              }\n            : {}),\n          style: { position: \"relative\", zIndex: 2 },\n        }\n      },\n      [focusedIndex, isDisabled, isFocusVisible, isReadOnly, onFocus, value],\n    )\n\n    useEffect(() => {\n      return trackFocusVisible(setIsFocusVisible)\n    }, [])\n\n    useEffect(() => {\n      setActivePosition(getActivePosition())\n    }, [focusedIndex, containerRect, value, getActivePosition])\n\n    const css: CSSUIObject = {\n      position: \"relative\",\n      display: \"inline-flex\",\n      alignItems: \"center\",\n      ...styles.container,\n    }\n\n    const validChildren = getValidChildren(children)\n    let computedChildren: ReactElement[] = []\n\n    if (!validChildren.length && items.length) {\n      computedChildren = items.map(({ label, value, ...props }, i) => (\n        <SegmentedControlButton key={i} value={value} {...props}>\n          {label}\n        </SegmentedControlButton>\n      ))\n    } else {\n      computedChildren = validChildren\n    }\n\n    if (value == null && rest.defaultValue == null) {\n      for (const child of computedChildren) {\n        if (child.type !== SegmentedControlButton) continue\n\n        const value = child.props.value\n\n        setValue(value)\n\n        break\n      }\n    }\n\n    return (\n      <DescendantsContextProvider value={descendants}>\n        <SegmentedControlProvider\n          value={{ getInputProps, getLabelProps, styles }}\n        >\n          <ui.div\n            {...getContainerProps({}, ref)}\n            className={cx(\"ui-segmented-control\", className)}\n            __css={css}\n          >\n            {isMoutedRef.current ? (\n              <ui.span\n                className=\"ui-segmented-control__active\"\n                {...getActiveProps()}\n                __css={styles.active}\n              />\n            ) : null}\n\n            {computedChildren}\n          </ui.div>\n        </SegmentedControlProvider>\n      </DescendantsContextProvider>\n    )\n  },\n)\n\ntype SegmentedControlButtonOptions = {\n  /**\n   * The value of the segmented control button.\n   */\n  value: string | number\n  /**\n   * The callback fired when any children radio is checked or unchecked.\n   */\n  onChange?: ChangeEventHandler<HTMLInputElement>\n}\n\nexport type SegmentedControlButtonProps = Omit<\n  HTMLUIProps<\"label\">,\n  \"onChange\"\n> &\n  Pick<SegmentedControlProps, \"isDisabled\" | \"isReadOnly\"> &\n  SegmentedControlButtonOptions\n\nexport const SegmentedControlButton = forwardRef<\n  SegmentedControlButtonProps,\n  \"input\"\n>(\n  (\n    {\n      className,\n      disabled,\n      readOnly,\n      isDisabled,\n      isReadOnly,\n      value,\n      onChange,\n      children,\n      ...rest\n    },\n    ref,\n  ) => {\n    const { getInputProps, getLabelProps, styles } = useSegmentedControl()\n\n    const { index, register } = useDescendant({\n      disabled: isDisabled || isReadOnly,\n    })\n\n    const props = {\n      index,\n      value,\n      onChange,\n      disabled,\n      readOnly,\n      isDisabled,\n      isReadOnly,\n    }\n\n    const css: CSSUIObject = {\n      cursor: \"pointer\",\n      flex: \"1 1 0%\",\n      display: \"inline-flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      ...styles.button,\n    }\n\n    return (\n      <ui.label\n        {...getLabelProps(omitObject(props, [\"onChange\"]))}\n        className={cx(\"ui-segmented-control__button\", className)}\n        __css={css}\n        {...rest}\n      >\n        <ui.input {...getInputProps(props, mergeRefs(register, ref))} />\n        <ui.span>{children}</ui.span>\n      </ui.label>\n    )\n  },\n)\n"],"names":["DescendantsContextProvider","useDescendants","useDescendant","createDescendant","SegmentedControlProvider","useSegmentedControl","createContext","SegmentedControl","forwardRef","props","ref","styles","mergedProps","useMultiComponentStyle","className","id","name","isReadOnly","isDisabled","children","items","rest","omitThemeProps","isMoutedRef","useIsMounted","useId","useCallbackRef","descendants","focusedIndex","setFocusedIndex","useState","isFocusVisible","setIsFocusVisible","observerRef","containerRect","useResizeObserver","containerRef","useRef","labelRefs","value","setValue","useControllableState","getActivePosition","useCallback","rect","el","paddingLeft","paddingTop","gutterX","gutterY","width","height","activePosition","setActivePosition","onChange","ev","onFocus","index","skip","next","onBlur","getContainerProps","omitObject","mergeRefs","ariaAttr","handlerAll","getActiveProps","x","y","getInputProps","disabled","readOnly","checked","dataAttr","getLabelProps","focused","node","useEffect","trackFocusVisible","css","validChildren","getValidChildren","computedChildren","label","i","jsx","SegmentedControlButton","child","jsxs","ui","cx","register"],"mappings":"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"}